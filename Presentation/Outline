% There's a couple of different points I want to hightlight in this presentation, which come down to:
% (1) How does the use of a functional language influence the design of the LF-runtime?
% (2) How can we use dependent types to our benefit for representing reactors generically?
% (3) What can we do wrt. verification in the Lean target?
%
% Recap what most of you know already:
%
% LF is a polyglot language for building programs according to the reactor model,
% which is a model of computation based on a notion of isolated units called reactors,
% which can only interact with eachother under very specific smeantics, including time semantics.
% These reactors in turn contain small computational units called reactions, 
% which can execute code and interact with their containing reactor according to specific firing semantics.
%
% We call LF a polyglot language, because the code that is executed by these reactions isn't tied to any specific programming languages.
% Instead, LF provides a framework which makes it possible to support any programming language as a "target".
% Currently there exist targets for C, C++, Rust, TypeScript, ...
%
% Now importantly, when writing an LF-program - all of the reactor-related stuff is expressed as LF-code.
% That is, when implementing an LF-target, you don't need to write a parser for declaring a reactor, 
% or creating a connection between ports or anything like that. Neither do you need to figure out whether
% the given structure of your reactor system is semantically correct (only output ports are connected to input ports, etc.).
% The LF-frontend handles this validation for you.
%
% This is all static information and is independent of target code (reaction bodies).
% What LF doesn't do is the dynamic part, i.e. give you a way to *execute* an LF-program.
% That needs to be handled by each target individually.
% What "handling the dynamic part" comes down to is implementing a runtime which executes
% the reactor system which the LF-frontend parsed and validated for you.
%
% That is, the compiler we're constructing here has three parts:
% (1) Run the LF-frontend (which parses and validates an LF-program)
% (2) Use the AST provided by LF to generate code in the target language which represents the reactor system
% (3) Generate program in the target language which executes the reactor system using some pre-implemented runtime
%
% So this is where our journey for this presentation starts:
% How do we execute reactors?
% And for that matter, how do we even represent the different parts of the reactor model in Lean?
%
% There's an obvious answer here, right?
% If reactors are these isolated units with internal functionality, that sounds awfully alot like a class.
% So let's just generate a class for each reactor and then the rest follows...
% 
% This is where I tell you that Lean is a functional language so we have no objects or mutable state of any kind.
% So, what now?
%
% What I'd like to do is to take you on a journey through the Lean target runtime in the order in which I approached its implementation.
% We'll start where we want to end up: (which will also address the first question from the top (1))
% Reaction bodies should look something like this:
%
% ...
%
% That is, they should be basically normal functions in Lean, but with the additional power of being able to read and mutate some "context".
% By context I mean things like ports, state variables, actions, etc ...
% But as I just said, Lean does not allow for mutable state.
% The way we (and in fact most functional languages) get around this is by using monads.
% Now there's a saying that you've only understood monads once you've written a blog post trying to explain them, so I won't try to explain the concept to you here.
% But I will have to cover them a little bit in order for reactions in the Lean target to make any sense.
% 
% The main mental step you need to take is the following.
% Monads are the tool in functional programming languages for adding context to a function.
% The way we do that is the following:
% Say you have a normal function like:
%
% def foo : Bool := ...
%
% And you want this function to be able to have access to a global mutable Nat, then we create the monad:
%
% def ContextM (A : Type) : Type := Nat -> (Nat x A)
% 
% and write:
%
% def foo : ContextM Bool := ... 
%
% What this unfolds to is:
%
% def foo : Nat -> Nat x Bool := ... 
%
% So really all we've done is explicitly add our "global mutable Nat" as an input and output to the function.
% So you can imagine that if we have multiple functions like `foo` and call them consecutively,
% what we want to do is plug them together so that the global state gets carried from one to the next.
% This is of course super annoying, so people have come up with smart abstractions that allow to do that implicitly.
% And in fact, these abstractions even allow the monad to decide how it wants to be chained (which will be important for us).
%
% So where does this apply in reactions?:
% Each of the lines containing a left arrow (<-) is a call to such a monadic function.
% That is, we're using it to either read from the context or write to the context.
% And then each of these lines is plugged together into a chain where the context is passed on from one to the next.
% (Side not for those in the know: It's because we're in a do-notatation block here).
%
% So much for the mechanics of things. The interesting part wrt to reactors is now what these contexts look like and how theyre plugged together.
%
% We have the following things we need to track during reaction execution:
% * input ports (readable)
% * output ports (writable)
% * state vars (read & write)
% * source actions (readable) 
% * scheduled actions (writable) 
% * stop request
%
% So we create our monad such that the input-context contains all of the reable things and the 
% output-context contains all of the writable things:
%
% ...
%
% Now for how we plug them together, let's go through an example covering three different aspects: input ports, state vars and scheduled actions
% Let's say our reaction looks as follows:
%
% <- getInput i
% <- setState s
% <- schedule a1
% <- schedule a2
% <- getState s
% <- getInput i
%
% Then our contexts develop as follows:
%
% ...
%
% The result is, that after the execution of a reaction, we've basically collected all of the things it's done,
% while also making sure that the reaction sees any updated state during its own execution.
%
% Now you can probably imagine what the execution of a reactor network looks like for one specific time tag:
% Given an order in which reactions are supposed to be executed, go through the list of reactions, and for each:
% (1) Check if the rection is triggered
% (2) Construct the "input context" for the reaction
% (3) Run the reaction on that input context
% (4) Integrate the output context into the reactor:
%    * update the state
%    * apply port values
%    * propagate port values along (non-delayed) connections
%    * add events to the queue
%    * register stop requests in the reactor system
%
% Going one step further, the entire execution of a reactor system then consists of an alternation of these "isntantaneous" steps,
% followed by a step where we increase the tag to the next event in the queue and update the state of the the reactors accordingly.
%
% So this answers question (1):
% The use of a functional language for the runtime implementation forces us to model everything as pure functions:
% * reactions are pure functions
% * instantaneous execution is a pure function
% * reactor execution is a (partial) pure function
% And the way in which we get mutatable state is by using monads (in reactions) and recursion (at the higher level of execution).
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Now as previously mentioned, there also exists a C target, and C doesn't have any objects either, so how does the Lean target differ from that?
% This is where we dive into the dependent-type aspect of Lean (the seconds question from the top (2)).
% 
% <have a graphic for this with two opposite facing arrows: coupling to lf-frontend vs. genericness/implementation complexity> 
%
% AFAIK, the way in which the C-target is able to implement reactors without having any concept of objects or generics, is by heavily relying
% on the code generator to generate code which is very much customized to each specific lf-program.
% That is, e.g. we don't have a generic structure for a reactor, but instead generate a custom structure for each reactor occurring in a concrete lf-program.
% While this is a totally valid approach, it does come with two downsides:
% (1) the code generator becomes more complex, which means writing a lot of java or kotlin (which i'm bad at)
% (2) there's a strong coupling between a target's code generation and the target's runtime implementation
%     aside from beeing less modular, this is also going to make it harder to test, because you're probably going to test your codegen along with your runtime impl
%
% Now the other extreme are the C++ and Rust targets, where the runtime are truly independent from the lf-frontend.
% This is of course great in terms of modularity and flexibility.
% AFAIK these target also required a lot of work as they implement some of the instance-graph functionality themselves, which is actually already provided by the LF-frontend
% (like creating an execution schedule).
%
% I neither wanted the strong coupling to the LF-frontend (and all the kotlin/java that entails)
% nor the complexity of reimplementing aspects of the lf-frontend, so the Lean target lives somewhere
% in the middle between these targets.
% What this means is that the Lean target provides generic structures like `Reactor` and `Reaction`, which are totally independent of the LF-frontend.
% But (and this is where the coupling to the lf-frontend comes in): 
% (a) instantiating these objects is a pain and 
% (b) we rely on the validation performed by the lf-frontend, as well as using it to generate the execution schedule.
%
% Now point (a) isn't completely true, because I've also implemented a DSL that generates the Lean-objects from a more readable syntax.
% So the workflow we get with the Lean target is:
%
% LF-frotend --super simple code gen--> DSL --actual, slightly harder but still simple code gen using Lean macros--> generic objects in Lean + generic runtime implementation that uses these objects
%
% So the hard part in this chain is the last part, i.e. finding a generic representation for reactor systems.
% And that's where dependent types in Lean come in handy.
% 
% Now dependent types are a bit like monads. 
% Explaining them fully isn't really an opion here, but they're integral to the implementation of reactors in Lean.
% Luckily there's a really small but extremely important type in the Lean target which nicely demonstrates dependent types: the `Interface` type.
%
% To explain this type, i'll approach it the same way i did when implementing the Lean target.
% Namely, you want to write a generic reactor type and you think about what you need:
% * input ports
% * output ports
% * state vars
% * values of actions
% and you notice that all these things have the same structure.
% Namely they consist of a set of "names", some function that tells you the type for each name, and a function that maps each name to a value of the associated type.
% The way we can implement this in Lean is as follows:
%
% structure Scheme where
%   vars : Type
%   type : vars → Type
%
% def Interface (σ : Scheme) := (var : σ.vars) → (σ.type var)
%
% As an example, if we wanted to represent the following state variables:
%   s1 : Nat, s2 : Int, s3 : Bool
% We would do that by:
%
% inductive StateNames
%   | s1 | s2 | s3
% 
% def stateScheme : Scheme where
%   vars := StateNames
%   type
%     | s1 => Nat
%     | s2 => Int
%     | s3 => Bool 
% 
% def stateInterface : Interface stateScheme
%   | s1 => 314
%   | s2 => -42
%   | s3 => true
%
% Now what this also shows is that we can seperate structuraly information from the actual data.
% Namely, the Scheme tells us exactly what a given interface will look like without containing any concrete data.
%
% What this leads to is the idea that we can actually just encode the *structure* of an entire reaction system first,
% and only for execution purposes actually attach data to it.
% And that's exactly how what we do in the Lean target.
%
% For example, we first define Reactor *Schemes* as:
%
% structure Reactor.Scheme (classes : Type) where
%   interface : InterfaceKind → Interface.Scheme
%   timers    : Type
%   children  : Type
%   «class»   : children → classes
%
% Then using this type, we can build a reactor graph:
%
% structure Network.Graph where
%   classes : Type
%   schemes : classes → (Reactor.Scheme classes)
%
% And finally, we for each class we also associate reactions and connections:
%
% structure Network extends Graph where
%   root        : Class toGraph
%   reactions   : (cls : Class toGraph) → Array (Class.Reaction cls)
%   connections : (cls : Class toGraph) → Class.Connections cls
%
% And to reiterate, a Network doesn't contain any data yet.
% Instead, it simply builds a class-graph (which is a DAG):
%
% ...
%
% What's cool about this class graph, is that it gives us a very intuitive notion of reactor instances.
% Namely, each path in the graph corresponds to an instance.
% But what's more, since we have all of this structuraly information lying around in this class-graph,
% any given path has an associated reaction scheme at its leaf. So we also know exactly what the given
% reactor should look like. Also, by navigating the class-graph we know exactly what each reactors'
% children should look like (ie. their reactor scheme).
% So the class-graph is really the central tool used by the Lean target to encode an entire reactor system,
% while only needing to encode its classes (and not its instances).
%
% Now during execution, we of course do need to associate data with each reactor instance.
% But that's really as simple as the mapping:
%
% (id : ReactorId net) → Reactor id.class
%
% Where `Reactor` is to `id.class`, what `Interface` was to `Scheme`.
%
% Now there are many more aspects of this design i'd like to talk about, but unfortunately that won't fit in this talk.
% But what I hope you have seen is that dependent types give us a really powerful tool for constructing generic objects
% which can represent lots of structural information about reactors. Hence we don't need to generate specific structures
% from the lf-frontend, but instead just generate specific instances of these scheme types and then parameterize other
% objects over these schemes.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 
% So let's move on to the third big question for this talk (3).
% What can Lean target do for us in terms of verification.
%
% To answer that question, we first need to consider the different possible flavors of verification:
%
% <1x2 chart>
% (1) User verification over reactions
% (2) Verification of correctness of the runtime 
%
% <2x2 chart>
% In both of these cases we need to split this up again:
% (1) instantaneous properties
% (2) time-based properties
%
% Currently, we can only consider the instantaneous side and not the time-based side due to the following hurdle:
% Proving time-based properties requires that we have some formalism (temporal logic) in which we can even express them.
% Currently, we don't have that for reactors, so this could be classified as future work.
%   Side note: 
%     Shaokai has expressed some interest in potentially looking at this in the future, 
%     and we also have some experts on temporal logics here in Dresden - so this could maybe become a collaborative effort.
%
% So let's consider the instantaneous side of things.
% First the boring one: runtime verification.
% This just consists of me sitting down and thinking about properties to verify about the runtime and then proving them.
% Instantaneous properties which might be interesting are, e.g.:
%  * the event queue never contains events from the past and is always ordered in time-increasing order
%  * if a reaction sets an output port, this port is in fact set after the reaction finishes executing
%    and all connected ports receive this same value
%  * if a reaction sets a state variable, the next reaction to be executed in the same reactor sees that change
%  * ...
%
% Why do we care about such properties?
% First of all, of course to make sure the runtime is correct.
% We do have tests in place, but a proof is worth an infinite number of tests, so that's better.
% Secondly, and more interestingly though, in the future these properties could become relevant for user-based proofs.
% And this brings us to the second and more interesting aspect of verification:
%
% User-based proofs are proofs written by users of LF, about specific reactions in concrete LF-programs.
% E.g. if we wrote the following reaction:
%
% ...
%
% We might want to prove that it satisfies property XYZ.
% In the Lean-target this is possible. We can declare an "epilogue" section with theorems.
% For our example reaction and property, that would look as follows:
%
% ... 
%
% Right now the workflow is very janky. Namely, you definitely want do the proving in the generated Lean-file,
% to benefit from the "interactive" aspects of Lean as an "interactive theorem prover".
%
% Why do we care about proofs over properties of reaction bodies?
% Again, proofs are worth an infinite number of tests. So knowing your reaction bodies are correct is nice.
% But there's also another benefit creeping up on the horizon, which brings us to more future work.
%
% Shaokai and I have been talking about combining his work on using SMT-solvers for model checking lf-programs with the Lean target.
% The motivation is the following:
% Currently, the model-checking capabilities only work on the C-target.
% The reason for this is that we for model checking to work for a specific lf-program, we need to know what the reactions are doing. 
% I.e. we need to analyze the target code in some way to extract properties from it.
% Shaokai has implemented such a tool for a certain subset of C, which can be converted to a certain normal form.
% But with user-based proofs, we can know the properties of any given reaction in the Lean target.
% So now the plan is to use these user-based proofs and generate axioms in UCLID for them.
% Then Shaokai's tool can come in and perform model checking on the program.